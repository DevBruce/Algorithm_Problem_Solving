# 2225 (합분해)

문제 링크: <https://www.acmicpc.net/problem/2225>

<br>

## 접근방법

- 다이나믹 프로그래밍

`D[n][k]` 를 `0 ~ n` 범위에 해당하는 수 k 개를 더하여  
n 을 만드는 방법의 수라고 정의한다.  

(순서가 다른 `0 + 1` 과 `1 + 0` 은 다른 경우로 본다.)  

<br>

예시를 통해 규칙을 살펴보자.  

`D[3][4]` 는 4 개의 수를 통해서 3 을 만드는 방법의 수가 된다.

즉 `1 + 0 + 2 + 1` 은 `D[3][4]` 가 되는 하나의 방법이 된다.  

아래에서 규칙을 찾아보겠다.    

<br>

**i )** 첫번째 수가 0 인 경우  

이 경우 식은 `0 + (? + ? + ?)` 가 된다.  

따라서 `(? + ? + ?)` 는 `D[3][3]` 이 됨을 알 수 있다.  

<br>

**ii )** 첫번째 수가 1 인 경우  

이 경우 식은 `1 + (? + ? + ?)` 이 된다.  

따라서 `(? + ? + ?)` 는 `D[2][3]` 이 된다.  

<br>

**iii )** 첫번째 수가 2 인 경우  

이 경우 식은 `2 + (? + ? + ?)` 이 된다.  

따라서 `(? + ? + ?)` 는 `D[1][3]` 이 된다.  

<br>

**iiii )** 첫번째 수가 3 인 경우  

이 경우 식은 `3 + (? + ? + ?)` 이 된다.  

따라서  `(? + ? + ?)` 는 `D[0][3]` 이 된다.  
이 경우 `(? + ? + ?)` 는 `(0, 0, 0)` 하나가 존재하므로  
**`D[0][k]` 의 형태는 1 가지 경우, 즉 1이 됨을 알 수 있다.**  

<br>

위의 예시를 일반화를 하면 다음과 같다.  

```python
D[3][4] = D[0][3] + D[1][3] + D[2][3] + D[3][3]
```

<br><br>

## 특이사항

- `D[n][0]` 는 존재하지 않으므로 0 이 된다.  

- `D[0][k]` 는 모두 0 이 되는 1 가지 경우가 존재하므로 1 이 된다.(`k = 0` 제외)  

- `D[1][k]` 는 k 가 된다.  
ex) `D[1][3]` 의 경우 `(1, 0, 0)`, `(0, 1, 0)`, `(0, 0, 1)` 3가지가 존재하게 된다.

- 결과값을 `1000000000` 로 나눈 나머지를 출력해야한다.

<br><br>

## Python3

Dynamic Programming (Bottom-Up)


### \# 1

```python
def get_cnt(n, k):
    d = [([0] * (k+1)) for _ in range(n+1)]
    d[0] = [1] * (k+1)
    d[0][0] = 0
    for i in range(1, n+1):
        d[i][1] = 1
        for j in range(2, k+1):
            for t in range(n+1):
                d[i][j] += d[t][j-1]
    return d[n][k]


N, K = map(int, input().split())
print(get_cnt(N, K) % 1000000000)
```

<br>

### \# 2

```python
d[n][k] = sum(d[n-1][:k+1])
```

위와같은 규칙을 발견하여 적용시킨 코드

```python
def get_cnt(n, k):
    d = [([0] * (k+1)) for _ in range(n+1)]
    d[0] = [1] * (k+1)
    d[0][0] = 0
    for i in range(1, n+1):   
        for j in range(k+1):
            d[i][j] = sum(d[i-1][:j+1])
    return d[n][k]


N, K = map(int, input().split())
print(get_cnt(N, K) % 1000000000)
```
